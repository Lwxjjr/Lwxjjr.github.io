[{"content":"","date":"2024-11-04T00:00:00Z","permalink":"https://Lwxjjr.github.io/p/http/","title":"Http"},{"content":"心路历程：\n前2题目没有考虑性质，写了很长的代码 第三题优化问题超时 第四题没看到（补） 1. 第k大的完美二叉树的大小 给你一棵二叉树 的根节点 root 和一个整数 k。\n返回第 k 大的完美二叉子树的大小，如果不存在则返回 -1。\n完美二叉树 是指所有叶子节点都在同一层级的树，且每个父节点恰有两个子节点。\n示例1：\n1 2 input: root = [5,3,6,5,2,5,7,1,8,null,null,6,8], k = 2 output: 3 解释：\n完美二叉子树的根节点在图中以黑色突出显示。\n它们的大小按非递增顺序排列为 [3, 3, 1, 1, 1, 1, 1, 1]。\n第 2 大的完美二叉子树的大小是 3。\n解答： 根据完美二叉树的定义，一颗高度为 `h` 的完美二叉树，从上往下，每一层有 $1, 2, 4, ..., 2^{h-1}$ 个节点，其子树的大小为 $1 + 2 + 4 + ... + 2^{h-1}$ = $2^h-1$，这样通过子树的高度既可确认子树的大小，我们在 **dfs** 中传参只需要传入高度即可。 **判断条件**： - 当前节点为空，返回 0 - 对于完美二叉树，左右子树的高度应该相等，判断如果相等则返回 `leftH+1`，否子返回`-1` 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func kthLargestPerfectSubtree(root *TreeNode, k int) int { ans := []int{} var dfs func(node *TreeNode) int dfs = func(node *TreeNode) int { if node == nil { return 0 } leftH := dfs(node.Left) rightH := dfs(node.Right) if leftH \u0026lt; 0 || rightH \u0026lt; 0 || leftH != rightH { return -1 // 不合法 } ans = append(ans, leftH+1) return leftH + 1 } dfs(root) // 完美二叉树的数量 \u0026lt; k 返回 -1 if k \u0026gt; len(ans) { return -1 } slices.Sort(ans) return 1\u0026lt;\u0026lt;ans[len(ans)-k] - 1 } 统计能获胜的出招序列数 Alice 和 Bob 正在玩一个幻想战斗游戏，游戏共有 n 回合，每回合双方各自都会召唤一个魔法生物：火龙（F）、水蛇（W）或地精（E）。每回合中，双方 同时 召唤魔法生物，并根据以下规则得分：\n如果一方召唤火龙而另一方召唤地精，召唤 火龙 的玩家将获得一分。 如果一方召唤水蛇而另一方召唤火龙，召唤 水蛇 的玩家将获得一分。 如果一方召唤地精而另一方召唤水蛇，召唤 地精 的玩家将获得一分。 如果双方召唤相同的生物，那么两个玩家都不会获得分数。 给你一个字符串 s，包含 n 个字符 'F'、'W' 和 'E'，代表 Alice 每回合召唤的生物序列：\n如果 s[i] == 'F'，Alice 召唤火龙。 如果 s[i] == 'W'，Alice 召唤水蛇。 如果 s[i] == 'E'，Alice 召唤地精。 Bob 的出招序列未知，但保证 Bob 不会在连续两个回合中召唤相同的生物。如果在 n 轮后 Bob 获得的总分 严格大于 Alice 的总分，则 Bob 战胜 Alice。\n返回 Bob 可以用来战胜 Alice 的不同出招序列的数量。\n由于答案可能非常大，请返回答案对 $10^9 + 7$ 取余后的结果。 示例1：\n1 2 input: s = \u0026#34;FFF\u0026#34; output: 3 解释： Bob 可以通过以下 3 种出招序列战胜 Alice：\u0026quot;WFW\u0026quot;、\u0026quot;FWF\u0026quot; 或 \u0026quot;WEW\u0026quot;。\n解答： 像打家劫舍一样，我们从后往前思考 因为不能连续2回合召唤相同的生物，我们需要一个变量来记录上个回合使用的生物，即这回合不能使用的生物\n我们在递归的过程中维护3个变量：\ni : 当前回合 diff ：当前和对手的分差 ban ：上个回合使用的生物，即这回合不能使用的生物 因此，定义dfs(i, diff, ban)为从i到0个回合，当前和对手的分差为diff，且第i回合我们无法召唤的生物为ban的情况下，战胜对手的不同出招序列的数量 下一步是思考如何定义状态转移\n在灵茶山艾府的周赛讲解中对F，W，E修改分别记作0，1，2，即枚举第i回合召唤的生物为 k = 0，1，2 \u0026amp;\u0026amp; k != ban。\n1 mp := {\u0026#34;F: 0\u0026#34;, \u0026#34;W: 1\u0026#34;, \u0026#34;E: 2\u0026#34;} 我们希望diff的值如下图所示（左右侧分别代表我方和对方选择生物）：\n这样看起来很完美，但是有 2 个特殊的组合该怎么处理？我们定义0，1，2的好处就来了，也就是3个值轮换，我们注意到有三个数字意味着(diff + 3) % 3 = diff，这样做可以比较好地处理所有的情况了，额外计算一下score = 2的情况即可，计算第i回合的差值score为：\n1 2 3 4 score := (k - mp[s[i]] + 3) % 3 if score == 2 { score = -1 } 显然，我们要记录从i到0的战胜对手不同出招序列的数量，又存在大量的递归调用，我们可以采取记忆化搜索的方式\n查看一下当前状态是否已经被计算过 不是：将状态及其结果记录到memo数组中 是：return memo保存的结果 然后枚举这回合能召唤的生物k且k!=ban 计算score 问题变成从i-1到0，我们和对手的分差为diff+score且第i-1回合我们无法召唤生物为k的情况下，战胜对手的不同出招序列的数量，dfs(i−1,diff+score,k) 维护res累加dfs(i−1,diff+score,k)，记录在dfs(i,diff,ban)中 这里注意 2 个减枝\n1 2 3 4 5 6 if -diff \u0026gt; i { return } if diff \u0026gt; i+1 { return pow2[i+1] } 如果 -diff \u0026gt; i，意味着现在的分差在后面的回合中全胜也无法战胜对手，返回 0 如果 diff \u0026gt; i，意味着即使后面全败也能战胜对手，因为还剩下i+1个回合，每回合去掉ban的生物，每回合能召唤 2 个生物中的一个，方案数为 $2^{i+1}$，返回 $2^{i+1}$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 func countWinningSequences(s string) int { const mod = 1_000_000_007 n := len(s) pow2 := make([]int, (n+1)/2) pow2[0] = 1 for i := 1; i \u0026lt; len(pow2); i++ { pow2[i] = pow2[i-1] * 2 % mod } mp := [...]int{\u0026#39;F\u0026#39;: 0, \u0026#39;W\u0026#39;: 1, \u0026#39;E\u0026#39;: 2} memo := make([][][3]int, n) for i := range memo { memo[i] = make([][3]int, n*2+1) for j := range memo[i] { memo[i][j] = [3]int{-1, -1, -1} } } /* i：第i回合，对手召唤是s[i] diff：分差 ban：这回合我们不能召唤的生物 */ var dfs func(int, int, int) int dfs = func(i, diff, ban int) (res int) { if -diff \u0026gt; i { return } if diff \u0026gt; i+1 { return pow2[i+1] } p := \u0026amp;memo[i][diff+n][ban] if *p != -1 { return *p } for k := 0; k \u0026lt; 3; k++ { // 枚举这回合能召唤的生物 if i == n-1 || k != ban { score := (k - mp[s[i]] + 3) % 3 if score == 2 { score = -1 } res += dfs(i-1, diff+score, k) } } res %= mod *p = res return } return dfs(n-1, 0, 0) } ","date":"2024-11-01T00:00:00Z","image":"https://Lwxjjr.github.io/p/%E5%91%A8%E8%B5%9B419/image_hu5793323311388220142.jpg","permalink":"https://Lwxjjr.github.io/p/%E5%91%A8%E8%B5%9B419/","title":"周赛419"}]